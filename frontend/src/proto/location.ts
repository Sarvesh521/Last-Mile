/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: location.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./google/api/annotations";
import * as dependency_2 from "./google/api/http";
import * as dependency_3 from "./google/protobuf/empty";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace com.lastmile.location.proto {
    export class MonitorDriverLocationRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            driver_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("driver_id" in data && data.driver_id != undefined) {
                    this.driver_id = data.driver_id;
                }
            }
        }
        get driver_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set driver_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            driver_id?: string;
        }): MonitorDriverLocationRequest {
            const message = new MonitorDriverLocationRequest({});
            if (data.driver_id != null) {
                message.driver_id = data.driver_id;
            }
            return message;
        }
        toObject() {
            const data: {
                driver_id?: string;
            } = {};
            if (this.driver_id != null) {
                data.driver_id = this.driver_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.driver_id.length)
                writer.writeString(1, this.driver_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MonitorDriverLocationRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MonitorDriverLocationRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.driver_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MonitorDriverLocationRequest {
            return MonitorDriverLocationRequest.deserialize(bytes);
        }
    }
    export class UpdateLocationRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            driver_id?: string;
            latitude?: number;
            longitude?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("driver_id" in data && data.driver_id != undefined) {
                    this.driver_id = data.driver_id;
                }
                if ("latitude" in data && data.latitude != undefined) {
                    this.latitude = data.latitude;
                }
                if ("longitude" in data && data.longitude != undefined) {
                    this.longitude = data.longitude;
                }
            }
        }
        get driver_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set driver_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get latitude() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set latitude(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get longitude() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set longitude(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            driver_id?: string;
            latitude?: number;
            longitude?: number;
        }): UpdateLocationRequest {
            const message = new UpdateLocationRequest({});
            if (data.driver_id != null) {
                message.driver_id = data.driver_id;
            }
            if (data.latitude != null) {
                message.latitude = data.latitude;
            }
            if (data.longitude != null) {
                message.longitude = data.longitude;
            }
            return message;
        }
        toObject() {
            const data: {
                driver_id?: string;
                latitude?: number;
                longitude?: number;
            } = {};
            if (this.driver_id != null) {
                data.driver_id = this.driver_id;
            }
            if (this.latitude != null) {
                data.latitude = this.latitude;
            }
            if (this.longitude != null) {
                data.longitude = this.longitude;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.driver_id.length)
                writer.writeString(1, this.driver_id);
            if (this.latitude != 0)
                writer.writeDouble(2, this.latitude);
            if (this.longitude != 0)
                writer.writeDouble(3, this.longitude);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateLocationRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateLocationRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.driver_id = reader.readString();
                        break;
                    case 2:
                        message.latitude = reader.readDouble();
                        break;
                    case 3:
                        message.longitude = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateLocationRequest {
            return UpdateLocationRequest.deserialize(bytes);
        }
    }
    export class UpdateLocationResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            success?: boolean;
            message?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            success?: boolean;
            message?: string;
        }): UpdateLocationResponse {
            const message = new UpdateLocationResponse({});
            if (data.success != null) {
                message.success = data.success;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            return message;
        }
        toObject() {
            const data: {
                success?: boolean;
                message?: string;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success != false)
                writer.writeBool(1, this.success);
            if (this.message.length)
                writer.writeString(2, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateLocationResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateLocationResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateLocationResponse {
            return UpdateLocationResponse.deserialize(bytes);
        }
    }
    export class GetLocationRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            driver_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("driver_id" in data && data.driver_id != undefined) {
                    this.driver_id = data.driver_id;
                }
            }
        }
        get driver_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set driver_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            driver_id?: string;
        }): GetLocationRequest {
            const message = new GetLocationRequest({});
            if (data.driver_id != null) {
                message.driver_id = data.driver_id;
            }
            return message;
        }
        toObject() {
            const data: {
                driver_id?: string;
            } = {};
            if (this.driver_id != null) {
                data.driver_id = this.driver_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.driver_id.length)
                writer.writeString(1, this.driver_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetLocationRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetLocationRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.driver_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetLocationRequest {
            return GetLocationRequest.deserialize(bytes);
        }
    }
    export class GetLocationResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            latitude?: number;
            longitude?: number;
            timestamp?: number;
            success?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("latitude" in data && data.latitude != undefined) {
                    this.latitude = data.latitude;
                }
                if ("longitude" in data && data.longitude != undefined) {
                    this.longitude = data.longitude;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
            }
        }
        get latitude() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set latitude(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get longitude() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set longitude(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set timestamp(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            latitude?: number;
            longitude?: number;
            timestamp?: number;
            success?: boolean;
        }): GetLocationResponse {
            const message = new GetLocationResponse({});
            if (data.latitude != null) {
                message.latitude = data.latitude;
            }
            if (data.longitude != null) {
                message.longitude = data.longitude;
            }
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.success != null) {
                message.success = data.success;
            }
            return message;
        }
        toObject() {
            const data: {
                latitude?: number;
                longitude?: number;
                timestamp?: number;
                success?: boolean;
            } = {};
            if (this.latitude != null) {
                data.latitude = this.latitude;
            }
            if (this.longitude != null) {
                data.longitude = this.longitude;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.success != null) {
                data.success = this.success;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.latitude != 0)
                writer.writeDouble(1, this.latitude);
            if (this.longitude != 0)
                writer.writeDouble(2, this.longitude);
            if (this.timestamp != 0)
                writer.writeInt64(3, this.timestamp);
            if (this.success != false)
                writer.writeBool(4, this.success);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetLocationResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetLocationResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.latitude = reader.readDouble();
                        break;
                    case 2:
                        message.longitude = reader.readDouble();
                        break;
                    case 3:
                        message.timestamp = reader.readInt64();
                        break;
                    case 4:
                        message.success = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetLocationResponse {
            return GetLocationResponse.deserialize(bytes);
        }
    }
    export class FindNearbyDriversRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            latitude?: number;
            longitude?: number;
            radius_km?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("latitude" in data && data.latitude != undefined) {
                    this.latitude = data.latitude;
                }
                if ("longitude" in data && data.longitude != undefined) {
                    this.longitude = data.longitude;
                }
                if ("radius_km" in data && data.radius_km != undefined) {
                    this.radius_km = data.radius_km;
                }
            }
        }
        get latitude() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set latitude(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get longitude() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set longitude(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get radius_km() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set radius_km(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            latitude?: number;
            longitude?: number;
            radius_km?: number;
        }): FindNearbyDriversRequest {
            const message = new FindNearbyDriversRequest({});
            if (data.latitude != null) {
                message.latitude = data.latitude;
            }
            if (data.longitude != null) {
                message.longitude = data.longitude;
            }
            if (data.radius_km != null) {
                message.radius_km = data.radius_km;
            }
            return message;
        }
        toObject() {
            const data: {
                latitude?: number;
                longitude?: number;
                radius_km?: number;
            } = {};
            if (this.latitude != null) {
                data.latitude = this.latitude;
            }
            if (this.longitude != null) {
                data.longitude = this.longitude;
            }
            if (this.radius_km != null) {
                data.radius_km = this.radius_km;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.latitude != 0)
                writer.writeDouble(1, this.latitude);
            if (this.longitude != 0)
                writer.writeDouble(2, this.longitude);
            if (this.radius_km != 0)
                writer.writeDouble(3, this.radius_km);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FindNearbyDriversRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FindNearbyDriversRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.latitude = reader.readDouble();
                        break;
                    case 2:
                        message.longitude = reader.readDouble();
                        break;
                    case 3:
                        message.radius_km = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FindNearbyDriversRequest {
            return FindNearbyDriversRequest.deserialize(bytes);
        }
    }
    export class FindNearbyDriversResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            drivers?: DriverLocation[];
            success?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("drivers" in data && data.drivers != undefined) {
                    this.drivers = data.drivers;
                }
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
            }
        }
        get drivers() {
            return pb_1.Message.getRepeatedWrapperField(this, DriverLocation, 1) as DriverLocation[];
        }
        set drivers(value: DriverLocation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            drivers?: ReturnType<typeof DriverLocation.prototype.toObject>[];
            success?: boolean;
        }): FindNearbyDriversResponse {
            const message = new FindNearbyDriversResponse({});
            if (data.drivers != null) {
                message.drivers = data.drivers.map(item => DriverLocation.fromObject(item));
            }
            if (data.success != null) {
                message.success = data.success;
            }
            return message;
        }
        toObject() {
            const data: {
                drivers?: ReturnType<typeof DriverLocation.prototype.toObject>[];
                success?: boolean;
            } = {};
            if (this.drivers != null) {
                data.drivers = this.drivers.map((item: DriverLocation) => item.toObject());
            }
            if (this.success != null) {
                data.success = this.success;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.drivers.length)
                writer.writeRepeatedMessage(1, this.drivers, (item: DriverLocation) => item.serialize(writer));
            if (this.success != false)
                writer.writeBool(2, this.success);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FindNearbyDriversResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FindNearbyDriversResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.drivers, () => pb_1.Message.addToRepeatedWrapperField(message, 1, DriverLocation.deserialize(reader), DriverLocation));
                        break;
                    case 2:
                        message.success = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FindNearbyDriversResponse {
            return FindNearbyDriversResponse.deserialize(bytes);
        }
    }
    export class DriverLocation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            driver_id?: string;
            latitude?: number;
            longitude?: number;
            distance_km?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("driver_id" in data && data.driver_id != undefined) {
                    this.driver_id = data.driver_id;
                }
                if ("latitude" in data && data.latitude != undefined) {
                    this.latitude = data.latitude;
                }
                if ("longitude" in data && data.longitude != undefined) {
                    this.longitude = data.longitude;
                }
                if ("distance_km" in data && data.distance_km != undefined) {
                    this.distance_km = data.distance_km;
                }
            }
        }
        get driver_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set driver_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get latitude() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set latitude(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get longitude() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set longitude(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get distance_km() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set distance_km(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            driver_id?: string;
            latitude?: number;
            longitude?: number;
            distance_km?: number;
        }): DriverLocation {
            const message = new DriverLocation({});
            if (data.driver_id != null) {
                message.driver_id = data.driver_id;
            }
            if (data.latitude != null) {
                message.latitude = data.latitude;
            }
            if (data.longitude != null) {
                message.longitude = data.longitude;
            }
            if (data.distance_km != null) {
                message.distance_km = data.distance_km;
            }
            return message;
        }
        toObject() {
            const data: {
                driver_id?: string;
                latitude?: number;
                longitude?: number;
                distance_km?: number;
            } = {};
            if (this.driver_id != null) {
                data.driver_id = this.driver_id;
            }
            if (this.latitude != null) {
                data.latitude = this.latitude;
            }
            if (this.longitude != null) {
                data.longitude = this.longitude;
            }
            if (this.distance_km != null) {
                data.distance_km = this.distance_km;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.driver_id.length)
                writer.writeString(1, this.driver_id);
            if (this.latitude != 0)
                writer.writeDouble(2, this.latitude);
            if (this.longitude != 0)
                writer.writeDouble(3, this.longitude);
            if (this.distance_km != 0)
                writer.writeDouble(4, this.distance_km);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DriverLocation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DriverLocation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.driver_id = reader.readString();
                        break;
                    case 2:
                        message.latitude = reader.readDouble();
                        break;
                    case 3:
                        message.longitude = reader.readDouble();
                        break;
                    case 4:
                        message.distance_km = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DriverLocation {
            return DriverLocation.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedLocationServiceService {
        static definition = {
            UpdateLocation: {
                path: "/com.lastmile.location.proto.LocationService/UpdateLocation",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: UpdateLocationRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => UpdateLocationRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: UpdateLocationResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => UpdateLocationResponse.deserialize(new Uint8Array(bytes))
            },
            GetLocation: {
                path: "/com.lastmile.location.proto.LocationService/GetLocation",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetLocationRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetLocationRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetLocationResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetLocationResponse.deserialize(new Uint8Array(bytes))
            },
            FindNearbyDrivers: {
                path: "/com.lastmile.location.proto.LocationService/FindNearbyDrivers",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: FindNearbyDriversRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => FindNearbyDriversRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: FindNearbyDriversResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => FindNearbyDriversResponse.deserialize(new Uint8Array(bytes))
            },
            MonitorDriverLocation: {
                path: "/com.lastmile.location.proto.LocationService/MonitorDriverLocation",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: MonitorDriverLocationRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MonitorDriverLocationRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: DriverLocation) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => DriverLocation.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract UpdateLocation(call: grpc_1.ServerUnaryCall<UpdateLocationRequest, UpdateLocationResponse>, callback: grpc_1.sendUnaryData<UpdateLocationResponse>): void;
        abstract GetLocation(call: grpc_1.ServerUnaryCall<GetLocationRequest, GetLocationResponse>, callback: grpc_1.sendUnaryData<GetLocationResponse>): void;
        abstract FindNearbyDrivers(call: grpc_1.ServerUnaryCall<FindNearbyDriversRequest, FindNearbyDriversResponse>, callback: grpc_1.sendUnaryData<FindNearbyDriversResponse>): void;
        abstract MonitorDriverLocation(call: grpc_1.ServerWritableStream<MonitorDriverLocationRequest, DriverLocation>): void;
    }
    export class LocationServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedLocationServiceService.definition, "LocationService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        UpdateLocation: GrpcUnaryServiceInterface<UpdateLocationRequest, UpdateLocationResponse> = (message: UpdateLocationRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<UpdateLocationResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<UpdateLocationResponse>, callback?: grpc_1.requestCallback<UpdateLocationResponse>): grpc_1.ClientUnaryCall => {
            return super.UpdateLocation(message, metadata, options, callback);
        };
        GetLocation: GrpcUnaryServiceInterface<GetLocationRequest, GetLocationResponse> = (message: GetLocationRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetLocationResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetLocationResponse>, callback?: grpc_1.requestCallback<GetLocationResponse>): grpc_1.ClientUnaryCall => {
            return super.GetLocation(message, metadata, options, callback);
        };
        FindNearbyDrivers: GrpcUnaryServiceInterface<FindNearbyDriversRequest, FindNearbyDriversResponse> = (message: FindNearbyDriversRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<FindNearbyDriversResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<FindNearbyDriversResponse>, callback?: grpc_1.requestCallback<FindNearbyDriversResponse>): grpc_1.ClientUnaryCall => {
            return super.FindNearbyDrivers(message, metadata, options, callback);
        };
        MonitorDriverLocation: GrpcStreamServiceInterface<MonitorDriverLocationRequest, DriverLocation> = (message: MonitorDriverLocationRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<DriverLocation> => {
            return super.MonitorDriverLocation(message, metadata, options);
        };
    }
}
